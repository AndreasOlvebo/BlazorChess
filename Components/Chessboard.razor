@using Models
@using Models.PieceTypes
@using Extensions

@inject IRefreshService RefreshService

<div class="board-border unselectable">
    <div class="container board-inner-border">
        @for (int i = Board.NumberOfRows - 1; i >= 0; i--)
        {
        <div class="row">
            @for (int j = 0; j < Board.NumberOfColumns; j++)
            {
                Tile tile = Board.Tiles[j, i];
                <div class="tile @Color(tile.Color) @(tile.Selected ? "selected" : "") " @onclick="() => ClickTile(tile)">
                    @((char)(65 + tile.TilePosition.X))@(tile.TilePosition.Y + 1)<br />
                    <ChessPiece Piece="tile.ChessPiece" />
                </div>
            }
        </div>
        }
    </div>
</div>

@code {
    [Parameter]
    public Board Board { get; set; }

    private PieceColor CurrentPlayer { get; set; } = PieceColor.White;

    private Tile PreviousTile { get; set; }
    public TurnHistory TurnHistory { get; set; }

    protected override async Task OnInitializedAsync()
    {

        await Task.Run(() =>
        {
            TurnHistory = new TurnHistory();
        });
    }

    private async void ClickTile(Tile clickedTile)
    {
        if (PreviousTile is not null)
        {
            if (PreviousTile == clickedTile)
            {
                DeselectTile(PreviousTile);
            }
            else if (PreviousTile.Occupied && IsPlayersTurn(PreviousTile.ChessPiece.PieceColor))
            {
                Position boardSize = new Position(Board.NumberOfColumns - 1, Board.NumberOfRows - 1);
                if (PreviousTile is not null && SpecialMove(clickedTile))
                {
                    DeselectTile(PreviousTile);
                    NextPlayer();
                }
                else
                {
                    (MoveAllowed allowMove, Action<Position> ConfirmMove) = PreviousTile.ChessPiece.IsMoveAllowed(boardSize, PreviousTile.TilePosition, clickedTile.TilePosition);
                    switch (allowMove)
                    {
                        case MoveAllowed.No:
                            DeselectTile(PreviousTile);
                            SelectTile(clickedTile);
                            break;
                        case MoveAllowed.Yes:
                            if (!clickedTile.Occupied || PreviousTile.ChessPiece.PieceColor != clickedTile.ChessPiece.PieceColor)
                            {
                                MoveChessPiece(clickedTile);
                                ConfirmMove(clickedTile.TilePosition);
                            }
                            else
                            {
                                DeselectTile(PreviousTile);
                                SelectTile(clickedTile);
                            }
                            break;
                        case MoveAllowed.IfEmpty:
                            if (!clickedTile.Occupied)
                            {
                                MoveChessPiece(clickedTile);
                                ConfirmMove(clickedTile.TilePosition);
                            }
                            break;
                        case MoveAllowed.IfAttack:
                            if (clickedTile.Occupied && PreviousTile.ChessPiece.PieceColor != clickedTile.ChessPiece.PieceColor)
                            {
                                MoveChessPiece(clickedTile);
                            }
                            break;
                        default:
                            break;
                    } 
                }
                await RefreshService.CallRequestRefresh();
            }
            else
            {
                SelectTile(clickedTile);
            }
        }
        else
        {
            SelectTile(clickedTile);
        }
    }

    private bool SpecialMove(Tile clickedTile)
    {
        //TODO: Any of tiles where king is moving (not only final position but the path there) cannot be in line of sight of any opposing piece.
        //Castling
        if (CastleAvailable(clickedTile))
        {
            (King king, Rook rook) = GetKingAndRook(clickedTile.ChessPiece, PreviousTile.ChessPiece);
            Castle((King)king, (Rook)rook);
            return true;
        }

        else if (EnPassantAvailable(PreviousTile.ChessPiece, clickedTile))
        {
            EnPassant(clickedTile);
            return true;
        }

        return false;
    }

    private bool EnPassantAvailable(Piece movingPiece, Tile clickedTile)
    {
        Piece lastMovedPiece = TurnHistory.LastTurn()?.MovedPiece;
        if (AnyNullObjects(movingPiece, lastMovedPiece))
        {
            return false;
        }
        lastMovedPiece.JsonPrint();
        if (IsPawn(lastMovedPiece) && IsPawn(movingPiece) && !AreAllies(lastMovedPiece, movingPiece))
        {
            if (movingPiece.PiecePosition.Y == lastMovedPiece.PiecePosition.Y
            && clickedTile.TilePosition.X == lastMovedPiece.PiecePosition.X
            && lastMovedPiece.PiecePosition.Difference(movingPiece.PiecePosition).Equals(new Position(1,0)))
            {
                return true;
            }
        }
        return false;
    }

    private void EnPassant(Tile clickedTile)
    {
        Tile enemyTile = Board.Tiles[TurnHistory.LastTurn().NewPosition];
        enemyTile.ChessPiece.Defeated = true;
        Turn turn = new Turn()
        {
            BoardState = Board.Clone(),
            MovedPiece = PreviousTile.ChessPiece.Clone(),
            OriginalPosition = PreviousTile.TilePosition,
            NewPosition = clickedTile.TilePosition,
            DefeatedPiece = enemyTile.ChessPiece?.Clone()
        };
        Board.DefeatedPieces.Add(enemyTile.ChessPiece);
        TurnHistory.AddTurn(Board, PreviousTile.ChessPiece, PreviousTile.TilePosition, clickedTile.TilePosition, enemyTile.ChessPiece);
        clickedTile.ChessPiece = PreviousTile.ChessPiece;
        enemyTile.ChessPiece = null;
        PreviousTile.ChessPiece = null;

    }

    private bool AnyNullObjects(params object[] objects)
    {
        return objects.Any(obj => obj is null);
    }

    private bool CastleAvailable(Tile clickedTile)
    {
        if (AnyNullObjects(clickedTile.ChessPiece, PreviousTile.ChessPiece))
        {
            return false;
        }
        if (AreAllies(clickedTile.ChessPiece, PreviousTile.ChessPiece) && OneOfEachType(clickedTile.ChessPiece, PreviousTile.ChessPiece, typeof(King), typeof(Rook)))
        {
            (King king, Rook rook) = GetKingAndRook(clickedTile.ChessPiece, PreviousTile.ChessPiece);
            if (king.FirstMove && rook.FirstMove)
            {
                return !Board.CollisionBetween(king.PiecePosition, rook.PiecePosition);
            }
        }
        return false;
    }

    private (King, Rook) GetKingAndRook(Piece a, Piece b)
    {
        Piece king = a.GetType() == typeof(King) ? a : b;
        Piece rook = a.GetType() == typeof(Rook) ? a : b;
        return ((King)king, (Rook)rook);
    }
    private void Castle(King king, Rook rook)
    {
        int kingX = rook.PiecePosition.Subtract(king.PiecePosition).X > 0 ? 2 : -2;
        int rookX = kingX > 0 ? 1 : -1;
        Board.Tiles[king.PiecePosition].ChessPiece = null;
        Board.Tiles[rook.PiecePosition].ChessPiece = null;
        Board.Tiles[king.PiecePosition.X + rookX, king.PiecePosition.Y].ChessPiece = rook;
        Board.Tiles[king.PiecePosition.X + kingX, king.PiecePosition.Y].ChessPiece = king;
    }

    private bool AreAllies(Piece a, Piece b)
    {
        return a.PieceColor == b.PieceColor;
    }

    private bool OneOfEachType(Piece a, Piece b, Type x, Type y)
    {
        return (a.GetType() == x && b.GetType() == y) || (a.GetType() == y && b.GetType() == x);
    }

    private bool IsPawn(Piece piece)
    {
        return piece.GetType() == typeof(Pawn);
    }

    private void SelectTile(Tile tile)
    {
        tile.Selected = true;
        DeselectTile(PreviousTile);
        PreviousTile = tile;
    }

    private void DeselectTile(Tile tile)
    {
        if (tile is not null)
        {
            tile.Selected = false;
            PreviousTile = null;
        }
    }

    private bool IsPlayersTurn(PieceColor player)
    {
        return player == CurrentPlayer || !Board.Options.EnableTurns;
    }

    private void NextPlayer()
    {
        if (Board.Options.EnableTurns)
        {
            CurrentPlayer = CurrentPlayer == PieceColor.White ? PieceColor.Black : PieceColor.White;
        }
    }

    private void MoveChessPiece(Tile clickedTile)
    {
        Piece defeatedPiece = null;
        if (clickedTile.Occupied)
        {
            defeatedPiece = clickedTile.ChessPiece;
            defeatedPiece.Defeated = true;
            Board.DefeatedPieces.Add(defeatedPiece);
        }
        clickedTile.ChessPiece = PreviousTile.ChessPiece;

        TurnHistory.AddTurn(Board, PreviousTile.ChessPiece, PreviousTile.TilePosition, clickedTile.TilePosition, defeatedPiece);

        PreviousTile.ChessPiece = null;

        DeselectTile(PreviousTile);
        NextPlayer();
    }

    private string Color(TileColor tileColor)
    {
        return tileColor == TileColor.White ? "white-tile" : "black-tile";
    }

}
